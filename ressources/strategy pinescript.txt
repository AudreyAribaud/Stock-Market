// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © sacha_baizet

//@version=6
strategy("Strat. Long", overlay = false, initial_capital = 10000, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)

riskPerc = input.float(1, title = "Risk %", step = 0.25) / 100
riskEquity = (riskPerc / 100) * strategy.equity

profitPerc = input.float(1, title = "Profit %", step = 0.25) / 100
profitEquity = (profitPerc / 100) * strategy.equity
profitAbs = input.int(50, title = "Profit amount", step = 5)



//------------------------------------------------------------------
// Fetch higher timeframe values
Stock_15M_Open = request.security(syminfo.tickerid, "15", open)
Stock_30M_Open = request.security(syminfo.tickerid, "30", open)
Stock_1D_Open = request.security(syminfo.tickerid, "D", open)

Stock_15M_Close = request.security(syminfo.tickerid, "15", close)
Stock_30M_Close = request.security(syminfo.tickerid, "30", close)
Stock_1D_Close = request.security(syminfo.tickerid, "D", close)

Stock_15M_High = request.security(syminfo.tickerid, "15", high)
Stock_30M_High = request.security(syminfo.tickerid, "30", high)
Stock_1D_High = request.security(syminfo.tickerid, "D", high)

Stock_15M_Low = request.security(syminfo.tickerid, "15", low)
Stock_30M_Low = request.security(syminfo.tickerid, "30", low)
Stock_1D_Low = request.security(syminfo.tickerid, "D", low)

Stock_15M_Volume = request.security(syminfo.tickerid, "15", volume)
Stock_30M_Volume = request.security(syminfo.tickerid, "30", volume)
Stock_1D_Volume = request.security(syminfo.tickerid, "D", volume)
//------------------------------------------------------------------

//------------------------------------------------------------------
// Relative LODs & HODs positions
HOD = request.security(syminfo.tickerid, "D", high)
LOD = request.security(syminfo.tickerid, "D", low)
HOD_1 = request.security(syminfo.tickerid, "D", high[1])
LOD_1 = request.security(syminfo.tickerid, "D", low[1])

is_above_HOD = close > HOD 
is_below_HOD = close < HOD
is_above_LOD = close > LOD
is_below_LOD = close < LOD
is_above_HOD_1 = close > HOD[1]
is_below_HOD_1 = close < HOD[1]
is_above_LOD_1 = close > LOD[1]
is_below_LOD_1 = close < LOD[1]

Lower_HOD = HOD < HOD[1]
Higher_LOD = LOD > LOD[1]
//--------------------

//------------------------------------------------------------------
// Check if current bar is less than 30 minutes after session open
// is_30_min_check = input.bool(true, 'Exclude first 30 min', "", group = "Global" )
is_X_min_check = input.int(30, "Exclude first X minutes", maxval = 30, step = 1, tooltip = "", group = "Global")

// is_30_min = is_30_min_check ? session.ismarket and timeframe.isintraday and hour(time) == 9 and minute(time) <= 59 : false
is_30_min = is_X_min_check == 0 ? false : (session.ismarket and timeframe.isintraday and hour(time) == 9 and minute(time) <= 30)



//------------------------------------------------------------------
// Keybars
//--------------------
// User-defined settings
atrLength = input.int(390, title = "ATR Length", minval = 1, group = "Keybars - inputs")
atrMultiplier = input.float(1, title = "ATR Multiplier", minval = 0.1, group = "Keybars - inputs")
volumeLength = input.int(390, title = "Volume Average Length", minval = 1, group = "Keybars - inputs")
bodySizePercentage = input.float(75, title = "Minimum Body Size %", minval = 0, maxval = 100, group = "Keybars - inputs")

// Calculating ATR, Volume Average, and Candle Body Size
atr = ta.atr(atrLength)
volumeAvg = ta.sma(volume, volumeLength)
bodySize = math.abs(close - open)  // Size of the candle body
totalRange = high - low  // Total range from high to low

// Key Bar Condition: Compare the body size with the ATR
is_keybar = (bodySize >= atrMultiplier * atr) and ((bodySize / totalRange) >= (bodySizePercentage / 100)) and (volume > volumeAvg)

// Determining Bullish or Bearish Key Bar
bullish_keybar = is_keybar and close > open
bearish_keybar = is_keybar and close < open

// Fetch the last keybars
var since_last_bullish_keybar = float(na)
var since_last_bearish_keybar = float(na)
since_last_bullish_keybar := ta.barssince(bullish_keybar)
since_last_bearish_keybar := ta.barssince(bearish_keybar)
//--------------------

//------------------------------------------------------------------
// Heinkin_Ashi candles
//--------------------
// Calculate HA values
ha_close = (open + high + low + close) / 4
ha_open = float(na)
ha_open := na(ha_open[1]) ? (open + close) / 2 : (ha_open[1] + ha_close[1]) / 2
ha_high = math.max(high, ha_open, ha_close)
ha_low = math.min(low, ha_open, ha_close)

// Detect HA candle color
haGreen = (ha_close > ha_open)
haRed = (ha_close < ha_open)
standardGreen = (open < close)
standardRed = (open > close)


// Detect flat HA
green_diff = math.abs(ha_low - ha_open)
red_diff = math.abs(ha_high - ha_open)
tolerance = 0.01 * syminfo.mintick

is_flat_green = haGreen and green_diff <= tolerance
is_flat_red = haRed and red_diff <= tolerance

// Detect green and red strikes
    // Price action is in a "green strike" when the last 3 consecutive HA candles of the same color were green
    // Price action is in a "red strike" when the last 3 consecutive HA candles of the same color were red
var bool Red_Strike = false
var bool Green_Strike = false

if (haGreen[1] and haGreen[2] and haGreen[3])
    Green_Strike := true
    Red_Strike := false
else if (haRed[1] and haRed[2] and haRed[3])
    Red_Strike := true
    Green_Strike := false

// Detect HA reversal pattern
    // First flat green HA candle after a red strike
bullishReversal = is_flat_green and Red_Strike and (not (is_flat_green[1] and Red_Strike[1])) and standardGreen

    // First flat red HA candle after a green strike
bearishReversal = is_flat_red and Green_Strike and (not (is_flat_red[1] and Green_Strike[1])) and standardRed

    // Track the latest reversal triggered
var latestSignal = float(na)
latestSignal := bullishReversal ? 1 : bearishReversal ? -1 : latestSignal

    // Count the number of bars since the last reversal
var lastBullishReversal = float(na)
var lastBearishReversal = float(na)
lastBullishReversal := ta.barssince(bullishReversal)
lastBearishReversal := ta.barssince(bearishReversal)
//--------------------

//------------------------------------------------------------------
// Real Relative Strength & Weakness indicator
//--------------------
// Price change (PC) and ATR length inputs
PC_Input = input(12, "Price change length", group = "RRS - inputs")
ATRLength_Input = input(12, "ATR Length", group = "RRS - inputs")

// Define a function to calculate the Power Index
calcPowerIndex(pc_len, atr_len) =>
    pc = close - close[pc_len]
    atr_val = ta.atr(atr_len)
    pc / atr_val

// Fetch the same calculation from other timeframes
Stock_PI_5M = request.security(syminfo.tickerid, "", calcPowerIndex(PC_Input, ATRLength_Input))
Stock_PI_15M = request.security(syminfo.tickerid, "15", calcPowerIndex(PC_Input, ATRLength_Input))
Stock_PI_30M = request.security(syminfo.tickerid, "30", calcPowerIndex(PC_Input, ATRLength_Input))
Stock_PI_1D = request.security(syminfo.tickerid, "D", calcPowerIndex(PC_Input, ATRLength_Input))

SPY_PI_5M = request.security("SPY", "", calcPowerIndex(PC_Input, ATRLength_Input))
SPY_PI_15M = request.security("SPY", "15", calcPowerIndex(PC_Input, ATRLength_Input))
SPY_PI_30M = request.security("SPY", "30", calcPowerIndex(PC_Input, ATRLength_Input))
SPY_PI_1D = request.security("SPY", "D", calcPowerIndex(PC_Input, ATRLength_Input))

// Calculate real relative strength
RRS_5M = Stock_PI_5M - SPY_PI_5M
RRS_15M = Stock_PI_15M - SPY_PI_15M
RRS_30M = Stock_PI_30M - SPY_PI_30M
RRS_1D = Stock_PI_1D - SPY_PI_1D

// Detect RRS sign changes
// RRS_5M_Crossover = ta.crossover(RRS_5M, 0)
// RRS_5M_Crossunder = ta.crossunder(RRS_5M, 0)
// RRS_15M_Crossover = ta.crossover(RRS_15M, 0)
// RRS_15M_Crossunder = ta.crossunder(RRS_15M, 0)
// RRS_30M_Crossover = ta.crossover(RRS_30M, 0)
// RRS_30M_Crossunder = ta.crossunder(RRS_30M, 0)
// RRS_1D_Crossover = ta.crossover(RRS_1D, 0)
// RRS_1D_Crossunder = ta.crossunder(RRS_1D, 0)
//--------------------

//------------------------------------------------------------------
// VWAP
//--------------------
// Relative to today's intraday VWAP
vwap = request.security(syminfo.tickerid, timeframe.period, ta.vwap)
is_above_vwap = close > vwap
is_below_vwap = close < vwap

vwap_15 = request.security(syminfo.tickerid, "15", ta.vwap)
is_above_vwap_15 = Stock_15M_Close > vwap_15
is_below_vwap_15 = Stock_15M_Close < vwap_15

vwap_30 = request.security(syminfo.tickerid, "30", ta.vwap)
is_above_vwap_30 = Stock_30M_Close > vwap_30
is_below_vwap_30 = Stock_30M_Close < vwap_30

// Get yesterday's averaged VWAP
    // For a more advanced session-aware approach:
is_new_day = dayofweek != dayofweek[1]
is_market_hours = session.ismarket  // Only during regular market hours

    // Reset VWAP calculation at the beginning of each day
var float daily_vwap = na
if is_new_day and is_market_hours
    daily_vwap := ta.vwap(close)
else if is_market_hours
    daily_vwap := ta.vwap(close)

    // Get yesterday's final VWAP value
yesterdays_final_vwap = request.security(syminfo.tickerid, "D", daily_vwap, gaps=barmerge.gaps_off)[1]
//--------------------

//------------------------------------------------------------------
// Relative volume (from CivilCucumber)
days = input.int(5, minval=1, title="N Day Average", group = "Relative volume")
highRVolThres = input.float(1.5, minval=0.0, step=0.1, title="RVol Highlight Thres.", group = "Relative volume")
cautionRVolThres = input.float(1.2, minval=1.0, step=0.1, title="RVol Soft Highlight Thres.", group = "Relative volume")
// colorPrevClose = input.bool(false, title="Color based on previous close")

var cVol = 0.0
var newDayBars = array.new_int()

// detect new session of day
isNewDay() =>
    t = time('D') // by default, time() follows symbol's session
    na(t[1]) and not na(t) or t[1] < t

if isNewDay()
    // reset cumulative volume
    cVol := 0
    
    // save new bars in circular array of length days + 1
    array.push(newDayBars, bar_index)
    if (array.size(newDayBars) > days + 1)
        array.shift(newDayBars)
    
    if timeframe.isintraday
        // mark new sessions on intraday charts
        line.new(bar_index, 0, bar_index, 0, extend=extend.left, color=color.gray, style=line.style_dotted)

// session start time, which is at regular intervals
timeSessionStart = time('D')

// cumulative volume
cVol := cVol + volume

// calculate relative volume
relativeVolume(cumVol) =>
    aVol = 0.0
    // check enough days saved in history to run (current day also saved)
    len = array.size(newDayBars)
    if len >= days + 1
        // SMA of historical cumulative volume up to but not including current time of day
        for i = 0 to len - 2
            b1 = array.get(newDayBars, i)
            b2 = array.get(newDayBars, i + 1)
            
            // use historical date but carry over current hour, minutes, seconds (this method is exact and avoids DST bugs)
            daysBetweenSessions = math.round((timeSessionStart - timeSessionStart[bar_index - b1]) / (24 * 60 * 60 * 1000))
            tLookup = timestamp(year(time), month(time), dayofmonth(time) - daysBetweenSessions, hour(time), minute(time), second(time))
            
            // get latest bar clamped in range [b1, b2) that is equal to or precedes given time (binary search for speed)
            int lo = math.max(0, b1) - 1
            int hi = math.max(0, b2)
            while 1 + lo < hi
                int mi = lo + math.floor((hi - lo) / 2)
                if (tLookup < time[bar_index - mi])
                    hi := mi
                else
                    lo := mi
            lo := lo < b1 ? hi : lo
            bClosest = b1 < b2 ? lo : -1
            
            // add cumulative volume to SMA calculation
            tClosest = time[bar_index - bClosest]
            aVol := aVol + (tLookup >= tClosest ? cumVol[bar_index - bClosest] / days : 0)
    aVol > 0 ? cumVol / aVol : na

rVol = relativeVolume(cVol)
//--------------------

//------------------------------------------------------------------ 
// ATR trailing stop
//--------------------

// Inputs
nATRPeriod = 12
nATRMultip = 3.5

// Calculate ATR
xATR = ta.atr(nATRPeriod)
nLoss = nATRMultip * xATR

// ATR Trailing Stop Calculation - Plot indicator
var float xATRTrailingStop = na

xATRTrailingStop := close > nz(xATRTrailingStop[1], 0) and close[1] > nz(xATRTrailingStop[1], 0) ? 
     math.max(nz(xATRTrailingStop[1]), close - nLoss) : 
     close < nz(xATRTrailingStop[1], 0) and close[1] < nz(xATRTrailingStop[1], 0) ? 
     math.min(nz(xATRTrailingStop[1]), close + nLoss) : 
     close > nz(xATRTrailingStop[1], 0) ? 
     close - nLoss : 
     close + nLoss

// Position Tracking
var int pos = na
pos := close[1] < nz(xATRTrailingStop[1], 0) and close > nz(xATRTrailingStop[1], 0) ? 1 : close[1] > nz(xATRTrailingStop[1], 0) and close < nz(xATRTrailingStop[1], 0) ? -1 : nz(pos[1], 0)

// Color Selection
color_atr_trail = pos == -1 ? #d10101 : pos == 1 ? #21cd27 : color.blue

// Plotting
plot(xATRTrailingStop, color = color_atr_trail, linewidth = 1, title="ATR Trailing Stop")

//--------------------
// Signal calculation logic
//--------------------
// Definition of sub-triggers
volume_sma_check = input.int(78, "Volume check - SMA length", step = 1, group = "Global")

// Enforced_RRS = input.bool(true,"D1 relative strength filter", "", group = "Signal checklist - Long")
// Enforced_RRW = input.bool(true,"D1 relative weakness filter", "", group = "Signal checklist - Short")
aligned_intraday_RS_check = input.bool(true,"Aligned relative strength filter", "", group = "Signal checklist - Long")
aligned_intraday_RW_check = input.bool(true,"Aligned relative weakness filter", "", group = "Signal checklist - Short")
// RRS_5M_Crossover_check = input.bool(true,"RRS 5m crossover 0", "", group = "Signal checklist - Long")
// RRS_5M_Crossunder_check = input.bool(true,"RRS 5m crossunder 0", "", group = "Signal checklist - Short")
// RRS_15M_Crossover_check = input.bool(true,"RRS 15m crossover 0", "", group = "Signal checklist - Long")
// RRS_15M_Crossunder_check = input.bool(true,"RRS 15m crossunder 0", "", group = "Signal checklist - Short")
RRS_30M_Crossover_check = input.bool(true,"RRS 30m crossover 0", "", group = "Signal checklist - Long")
RRS_30M_Crossunder_check = input.bool(true,"RRS 30m crossunder 0", "", group = "Signal checklist - Short")

// breakout_vwap_check = input.bool(true, "VWAP breakout", "", group = "Signal checklist - Long")
// breakdown_vwap_check = input.bool(true, "VWAP breakdown", "", group = "Signal checklist - Short")
keybar_breakout_vwap_check = input.bool(true, "Keybar VWAP breakout", "", group = "Signal checklist - Long")
keybar_breakdown_vwap_check = input.bool(true, "Keybar VWAP breakdown", "", group = "Signal checklist - Short")

red_to_green_strike_check = input.bool(true, "Red to green strike", "", group = "Signal checklist - Long")
green_to_red_strike_check = input.bool(true, "Green to red strike", "", group = "Signal checklist - Short")

HA_bullish_reversal_check = input.bool(true, "HA bullish reversal", "", group = "Signal checklist - Long")
HA_bearish_reversal_check = input.bool(true, "HA bearish reversal", "", group = "Signal checklist - Short")

bullish_thrust_check = input.bool(true, "Bullish thrust", "", group = "Signal checklist - Long")
bearish_thrust_check = input.bool(true, "Bearish thrust", "", group = "Signal checklist - Short")

atr_trailing_bullish_cross_check = input.bool(true, "ATR trailing stop bullish cross", "", group = "Signal checklist - Long")
atr_trailing_bearish_cross_check = input.bool(true, "ATR trailing stop bearish cross", "", group = "Signal checklist - Short")

HOD_1_breakout_check = input.bool(true, "Breakout of HOD[1]", "", group = "Signal checklist - Long")
LOD_1_breakdown_check = input.bool(true, "Breakdown of LOD[1]", "", group = "Signal checklist - Short")


// stable_D1_RS = Enforced_RRS ? (RRS_1D[1] > 0) and (RRS_1D[2] > 0) and (RRS_1D[3] > 0) : true
// stable_D1_RW = Enforced_RRW ? (RRS_1D[1] < 0) and (RRS_1D[2] < 0) and (RRS_1D[3] < 0) : true

// RRS_5M_Crossover = RRS_5M_Crossover_check ? ta.crossover(RRS_5M, 0) : false
// RRS_5M_Crossunder = RRS_5M_Crossunder_check ? ta.crossunder(RRS_5M, 0) : false
// RRS_15M_Crossover = RRS_15M_Crossover_check ? ta.crossover(RRS_15M, 0) : false
// RRS_15M_Crossunder = RRS_15M_Crossunder_check ? ta.crossunder(RRS_15M, 0) : false
RRS_30M_Crossover = RRS_30M_Crossover_check ? ta.crossover(RRS_30M, 0) : false
RRS_30M_Crossunder = RRS_30M_Crossunder_check ? ta.crossunder(RRS_30M, 0) : false

aligned_intraday_RS = aligned_intraday_RS_check ? ((RRS_15M > 0) and (RRS_5M > 0)) : true
aligned_intraday_RW = aligned_intraday_RW_check ? ((RRS_15M < 0) and (RRS_5M < 0)) : true

// breakout_vwap = breakdown_vwap_check ? (open < vwap) and (close > vwap) : false
// breakdown_vwap = breakdown_vwap_check ? (open > vwap) and (close < vwap) : false

keybar_breakout_vwap = keybar_breakout_vwap_check ? bullish_keybar and (open < vwap) and (close > vwap) : false
keybar_breakdown_vwap = keybar_breakdown_vwap_check ? bearish_keybar and (open > vwap) and (close < vwap) : false

HA_bullish_reversal = HA_bullish_reversal_check ? bullishReversal : false
HA_bearish_reversal = HA_bearish_reversal_check ? bearishReversal : false
red_to_green_strike = red_to_green_strike_check ? Red_Strike[1] and Green_Strike : false
green_to_red_strike = green_to_red_strike_check ? Green_Strike[1] and Red_Strike : false

volume_above_average = volume > ta.sma(volume, volume_sma_check)
high_relative_volume = rVol >= 1.2

// below_long_entry = close < open[ta.barssince(validEnterLong) + 1]
// above_short_entry = close > open[ta.barssince(validEnterShort) + 1]

is_long_bullish = (close > open) and (bodySize >= 0.8 * ta.atr(12)) and (bodySize / totalRange >= 0.8)
is_long_bearish = (close < open) and (bodySize >= 0.8 * ta.atr(12)) and (bodySize / totalRange >= 0.8)
bullish_thrust = bullish_thrust_check ? (is_long_bullish and is_long_bullish[1]) or (bullish_keybar and bullish_keybar[1]) : false
bearish_thrust = bearish_thrust_check ? (is_long_bearish and is_long_bearish[1]) or (bearish_keybar and bearish_keybar[1]) : false

atr_trailing_bullish_cross = atr_trailing_bullish_cross_check ? (pos[1] == -1 and pos == 1) : false
atr_trailing_bearish_cross = atr_trailing_bearish_cross_check ? (pos[1] == 1 and pos == -1) : false

HOD_1_breakout = is_long_bullish and (open < HOD_1) and (close > HOD_1)
LOD_1_breakdown = is_long_bearish and (open > LOD_1) and (close < LOD_1)

//--------------------
// Enter Long Signal
Enter_Long = aligned_intraday_RS and (volume_above_average or high_relative_volume) and (HA_bullish_reversal or keybar_breakout_vwap or red_to_green_strike or bullish_thrust or atr_trailing_bullish_cross or RRS_30M_Crossover or HOD_1_breakout)

// Exit Long Signal
Exit_Long = bearishReversal

// Enter Short Signal
Enter_Short = aligned_intraday_RW and (volume_above_average or high_relative_volume) and (HA_bearish_reversal or keybar_breakdown_vwap or green_to_red_strike or bearish_thrust or atr_trailing_bearish_cross or RRS_30M_Crossunder or LOD_1_breakdown)

// Exit Short Signal
Exit_Short = bullishReversal



// Orders executions

// Profit_Distance = profitPerc * (strategy.initial_capital + strategy.netprofit) / strategy.position_size
// Loss_Distance = riskPerc * (strategy.initial_capital + strategy.netprofit) / strategy.position_size



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Profit_Target_Check = input.bool(true, "Profit target?", "", group = "Strategy - Long")

var bool in_long_position = false

var float Entry_Price = na
var float Entry_Size = na

var float Long_TP = na
var float Long_SL = na


if Enter_Long
    strategy.entry("Long", strategy.long)
    in_long_position := true

Entry_Price := strategy.opentrades.entry_price(0)
Entry_Size := strategy.opentrades.size(0)


if in_long_position
    Long_TP := Profit_Target_Check ? Entry_Price * (1 + profitPerc) : na
    Long_SL := (close <= xATRTrailingStop) ? Entry_Price * (1 - riskPerc) : xATRTrailingStop


strategy.exit("Exit", "Long", limit = Long_TP, stop = Long_SL)


if ta.change(strategy.closedtrades) == 1
    // Reset the `takeProfit` and `stopLoss`.
    in_long_position := false
    Entry_Price := na
    Entry_Size := na
    Long_TP := na
    Long_SL := na


plot(Long_TP, "TP", color.green, 2, plot.style_linebr)
plot(Long_SL, "TSL", color.blue, 2, plot.style_linebr)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

